// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma shader_feature STEREO_CUBEMAP_RENDER

// Constants
static const float PI = 3.14159265f;

// Output parameters
RWTexture2D<float4> Position;
RWTexture2D<float4> Direction;
RWTexture2D<float4> Momentum;
RWTexture2D<float4> Color;
RWTexture2D<int> isComplete;
RWTexture2D<float> TimeStep;
RWTexture2D<float> ErrorTolerance;

// Input textures
Texture2D<float4> _SkyboxTexture;

// Step size parameters
//float timeStep;

// Samplers
SamplerState sampler_SkyboxTexture;

// Physical parameters 
float horizonRadius;
float diskRadius;

// Blend transparency and background colors
float4 Blend(float4 foreColor, float4 backColor)
{
    // Blend using previous color's alpha
    //float4 outColor = foreColor + backColor * (1.0 - foreColor.w);
    float4 outColor = foreColor + backColor;
    return outColor;
}

float3 SampleBackground(float4 x, float3 x_0)
{
    float dist = sqrt(((x[1] - x_0[0]) * (x[1] - x_0[0])) + ((x[2] - x_0[1]) * (x[2] - x_0[1])) + ((x[3] - x_0[2]) * (x[3] - x_0[2])));
    float theta = (acos((x[2] - x_0[1]) / dist)) / -PI;
    float phi = atan2((x[1] - x_0[0]), -(x[3] - x_0[2])) / PI * 0.5f;
    float3 skyAlpha = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    return skyAlpha;
}

float Pow7(float input)
{
    return input * input * input * input * input * input * input;
}

float Pow2(float input)
{
    return input * input;
}

float Pow3(float input)
{
    return input * input * input;
}

float Pow4(float input)
{
    return input * input * input * input;
}

float Lapse(float t, float r)
{
    float rho_s = horizonRadius;
    //return ((1 - rho_s / r) / (1 + rho_s / r));
    return 1.0;
    
}

float Betar(float t, float r)
{
    return 0;
}

float gammarr(float t, float r)
{
    float rho_s = horizonRadius;
    //return Pow4(1 + (rho_s / r));
    return 1.0;
}

float gammaT(float t, float r)
{
    float rho_s = horizonRadius;
    //return Pow4(1 + (rho_s / r));
    return 1.0;
}

float4x4 Jacobian(float4 x)
{
    float r = x[1];
    float theta = x[2];
    float phi = x[3];

    float4x4 J =
    {
        {1, 0, 0, 0},
        {0, sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)},
        {0, (1/r)*cos(theta)*cos(phi), (1/r)*cos(theta)*sin(phi), -(1/r)*(sin(theta))},
        {0, -(1/r)*(sin(phi)/(sin(theta))), (1/r)*cos(phi)/sin(theta), 0}
    };

    return J;
}

float4x4 InverseJacobian(float4 x)
{
    float r = x[1];
    float theta = x[2];
    float phi = x[3];

    float4x4 J_inv = 
    {
        {1, 0, 0, 0},
        {0, sin(theta)*cos(phi), r*cos(theta)*cos(phi), -r*sin(theta)*sin(phi)},
        {0, sin(theta)*sin(phi), r*cos(theta)*sin(phi), r*sin(theta)*cos(phi)},
        {0, cos(theta), -r*sin(theta), 0}
    };

    return J_inv;
}

float3 CartesianToSpherical(float3 xyz)
{
    float r = sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1] + xyz[2]*xyz[2]);
    float theta = acos(xyz[2]/r);
    float phi = acos(xyz[0]/(max(sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1]), 1e-10)));

    float3 x_spherical;
    x_spherical[0] = max(r, 1e-10);
    x_spherical[1] = theta;
    x_spherical[2] = phi;

    return x_spherical;
}

float3 SphericalToCartesian(float3 rThetaPhi)
{

}

float4x4 Metric(float4 x)
{
    float3 xyz;
    xyz[0] = x[1];
    xyz[1] = x[2];
    xyz[2] = x[3];
    float3 rThetaPhi = CartesianToSpherical(xyz);
    float4 x_spherical;
    x_spherical[0] = x[0];
    x_spherical[1] = rThetaPhi[0];
    x_spherical[2] = rThetaPhi[1];
    x_spherical[3] = rThetaPhi[2];
    float r = rThetaPhi[0];
    float alpha = Lapse(x[0], rThetaPhi[0]);
    float betar = Betar(x[0], rThetaPhi[0]);
    float g_rr = gammarr(x[0], rThetaPhi[0]);
    float g_T = gammaT(x[0], rThetaPhi[0]);

    float4x4 g_Spherical =
    {{-Pow2(alpha * betar) * g_rr, g_rr * betar, 0, 0},
    {g_rr * betar, g_rr, 0, 0},
    {0, 0, g_T * r * r, 0},
    {0, 0, 0, g_T * r * r * Pow2(sin(rThetaPhi[1]))}};

    float4x4 g_Cartesian = 
    {
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0}
    };

    float4x4 J = Jacobian(x_spherical);
    [unroll]
    for(int a = 0; a < 4; a++)
    {
        [unroll]
        for(int b = 0; b < 4; b++)
        {
            

            [unroll]
            for(int c = 0; c < 4; c++)
            {
                [unroll]
                for(int d = 0; d < 4; d++)
                {
                    g_Cartesian[a][b] += g_Spherical[c][d] * J[c][a] * J[d][b];
                }
            }
        }
    }

    float4x4 g_flat = 
    {
        {-1, 0, 0, 0},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {0, 0, 0, 1}
    };
    
    return g_Cartesian;
}

    float4x4 InverseMetric(float4 x)
    {
        float3 xyz;
        xyz[0] = x[1];
        xyz[1] = x[2];
        xyz[2] = x[3];
        float3 rThetaPhi = CartesianToSpherical(xyz);
        float4 x_spherical;
        x_spherical[0] = x[0];
        x_spherical[1] = rThetaPhi[0];
        x_spherical[2] = rThetaPhi[1];
        x_spherical[3] = rThetaPhi[2];
        float r = rThetaPhi[0];
        float theta = rThetaPhi[1];

        float alpha = Lapse(x[0], rThetaPhi[0]);
        float betar = Betar(x[0], rThetaPhi[0]);
        float g_rr = gammarr(x[0], rThetaPhi[0]);
        float g_T = gammaT(x[0], rThetaPhi[0]);

        float4x4 g_Spherical =
        {{-1 / Pow2(alpha), betar / (Pow2(alpha)), 0, 0},
        {betar / Pow2(alpha), (1 / (g_rr)) - Pow2(betar/alpha), 0, 0},
        {0, 0, 1 / (g_T * r * r), 0},
        {0, 0, 0, 1 / (g_T * Pow2(r * sin(theta)))}};

        float4x4 g_Cartesian = 
        {
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0}
        };
        float4x4 J_inv = InverseJacobian(x_spherical);

        [unroll]
        for(int a = 0; a < 4; a++)
        {
            [unroll]
            for(int b = 0; b < 4; b++)
            {
                g_Cartesian[a][b] = 0;
                [unroll]
                for(int c = 0; c < 4; c++)
                {
                    [unroll]
                    for(int d = 0; d < 4; d++)
                    {
                        g_Cartesian[a][b] += g_Spherical[c][d] * J_inv[a][c] * J_inv[b][d];
                    }
                }
            }
        }

            float4x4 g_flat = 
        {
            {-1, 0, 0, 0},
            {0, 1, 0, 0},
            {0, 0, 1, 0},
            {0, 0, 0, 1}
        };

        return g_Cartesian;
    }
    
    float4x4 Derivative(float4 x, int a)
    {
        float h = 0.01;
        float4 deltaPlus_x = x;
       
        deltaPlus_x[a] += h;
        float4x4 gPlus = Metric(deltaPlus_x);
        
        float4 deltaMinus_x = x;
        deltaMinus_x[a] -= h;
        float4x4 gMinus = Metric(deltaMinus_x);

        float4x4 dg;
        [unroll]
        for(int b = 0; b < 4; b++)
        {
            [unroll]
            for(int c = 0; c < 4; c++)
            {
                dg[b][c] = (gPlus[b][c] - gMinus[b][c]) / (2 * h);
            }
        }
        
        return dg;
    }

    bool ShootRay(inout float dt, float tol, inout float4 x_u, inout float4 u_u)
    { 
    float4 rhs_x_u;
    float4 rhs_u_u;
    float4 rhs_u_d;

    float4 x_u_star;
    float4 u_d_star;
    float4 u_u_star;

    float4 x_u_euler;
    float4 u_d_euler;
    float4 u_u_euler;

    float4 u_d;

    float4x4 g_dd = Metric(x_u);

    bool isGood = false;

    float error;

    float dt_min = 1e-10;

    [unroll]
    for(int a = 0; a < 4; a++)
    {
        u_d[a] = 0.0;
        [unroll]
        for(int b = 0; b < 4; b++)
        {
            u_d[a] += g_dd[a][b] * u_u[b];
        }
    }

    [unroll]
    for(int a = 0; a < 4; a++)
    {
        rhs_x_u[a] = -u_u[a];
        
        rhs_u_d[a] = 0.0;

        // [unroll]
        // for(int i = 0; i < 4; i++)
        // {
        //     [unroll]
        //     for(int j = 0; j < 4; j++)
        //     {
        //         dg_dd[i][j] = Derivative(x_u, a)[i][j];
        //     }
        // }

        float4x4 dg_dd = Derivative(x_u, a); 

        [unroll]
        for(int b = 0; b < 4; b++)
        {
            [unroll]
            for(int c = 0; c < 4; c++)
            {
                rhs_u_d[a] -= ((0.5) * dg_dd[b][c] * u_u[b] * u_u[c]);
            }
        }
    }

    [unroll]
    for(int a = 0; a < 4; a++)
    {
        x_u_star[a] = x_u[a] + (0.5)*dt*rhs_x_u[a];
        u_d_star[a] = u_d[a] + (0.5)*dt*rhs_u_d[a];
    }

    float4x4 g_uu = InverseMetric(x_u_star);

    [unroll]
    for(int a = 0; a < 4; a++)
    {
        u_u_star[a] = 0.0;
        
        [unroll]
        for(int b = 0; b < 4; b++)
        {
            u_u_star[a] += g_uu[a][b] * u_d_star[b];
        }
    }

    [unroll]
    for(int a = 0; a < 4; a++)
    {
        x_u_euler[a] = x_u[a] + dt*rhs_x_u[a];
        u_d_euler[a] = u_d[a] + dt*rhs_u_d[a];
    }

    [unroll]
    for(int a = 0; a < 4; a++)
    {
        rhs_x_u[a] = -u_u_star[a];
        //rhs_u_d[a] = 0.0;
        float4x4 dg_dd = Derivative(x_u_star, a); 
        [unroll]
        for(int b = 0; b < 4; b++)
        {
            [unroll]
            for(int c = 0; c < 4; c++)
            {
                rhs_u_d[a] -= (0.5) * (dg_dd[b][c] * u_u_star[b] * u_u_star[c]);
            }
        }
    }

    [unroll]
    for(int a = 0; a < 4; a++)
    {
        x_u_star[a] = x_u[a] + dt*rhs_x_u[a];
        u_d_star[a] = u_d[a] + dt*rhs_u_d[a];
    }

    error = 0.0;
    [unroll]
    for(int i = 1; i < 4; i++)
    {
        error += abs(x_u_star[i] - x_u_euler[i]);
    }

    if(error < tol || dt <= dt_min)
    {
        isGood = true;
        [unroll]
        for(int i = 0; i < 4; i++){
            x_u[i] = x_u_star[i];
        }

        g_uu = InverseMetric(x_u);

        [unroll]
        for(int a = 0; a < 4; a++){ 
            u_d[a] = u_d_star[a];
        }

        [unroll]
        for(int a = 0; a < 4; a++)
        {
            u_u[a] = 0.0;

            [unroll]
            for(int b = 0; b < 4; b++)
            {
                u_u[a] += g_uu[a][b] * u_d[a];
            }
        }
        
        if(4*error < tol)
        {
            dt = dt * 2.0;
        }
    }

    else if(error > tol)
    {
        dt *= 0.5;
    } 
    return isGood;  
    // float k[8];

    // float u_star[8];

    // float u_euler[8];

    // float error;

    // float u_trial[8];

    // float dt_min = 1e-10;

    // float4x4 Christoffel[4];

    // bool isGood = false;


    //     //SchwarzchildChristoffel(x[1], x[2], x[3], Christoffel);
        
    //     ComputeChristoffel(x, Christoffel);
  
    
    //     [unroll]
    //     for(int a = 0; a < 4; a++){
    //         k[a] = -u[a];
    //         k[a + 4] = 0.0;
       
    //         [unroll]
    //         for(int b = 0; b < 4; b++){
                
    //             [unroll]
    //             for(int c = 0; c < 4; c++){
    //                 k[a + 4] += (Christoffel[a])[b][c] * u[b] * u[c];
    //             }
    //         }
    //     }
            
     
        

    //     [unroll]
    //     for(int i = 0; i < 4; i++){
    //         u_star[i] = x[i] + (0.5)*dt*k[i];
    //         u_euler[i] = x[i] + dt*k[i];
    //     }

    //     [unroll]
    //     for(int i = 4; i < 8; i++){
    //         u_star[i] = u[i - 4] + (0.5)*dt*k[i];
    //         u_euler[i] = u[i - 4] + dt*k[i];
    //     }

    //     float4 u_star_x;
    //     u_star_x[0] = u_star[0];
    //     u_star_x[1] = u_star[1];
    //     u_star_x[2] = u_star[2];
    //     u_star_x[3] = u_star[3];

    //     ComputeChristoffel(u_star_x, Christoffel);
  
        // [unroll]
        // for(int a = 0; a < 4; a++){
        //     k[a] = -u_star[a+4];
        //     k[a + 4] = 0.0;
   
        //     [unroll]
        //     for(int b = 0; b < 4; b++){
                
        //         [unroll]
        //         for(int c = 0; c < 4; c++){
        //             k[a + 4] += (Christoffel[a])[b][c] * u_star[b + 4] * u_star[c + 4];
        //         }
        //     }
        // }
        
        // [unroll]
        // for(int i = 0; i < 4; i++){
        //     u_trial[i] = x[i] + dt*k[i];
        // }
        // [unroll]
        // for(int i = 4; i < 8; i++){
        //     u_trial[i] = u[i-4] + dt*k[i];

        // }

        // error = 0.0;
        // [unroll]
        // for(int i = 1; i < 4; i++){
        //     error += abs(u_trial[i] - u_euler[i]);
        // }

        // if(error < tol || dt <= dt_min){
        //     isGood = true;
        //     [unroll]
        //     for(int i = 0; i < 4; i++){
        //         x[i] = u_trial[i];
        //     }
            
        //     NullCondition(u_trial);

        //     [unroll]
        //     for(int i = 4; i < 8; i++){
                
        //         u[i-4] = u_trial[i];
            
        //     }
            
            
        //     if(4*error < tol){
        //         dt = dt * 2.0;
        //     }
        // }
        // else if(error > tol)
        // {

        //     dt *= 0.5;
        //     //dt = max(dt, 1e-3);
        // } 
        // return isGood;  
    
    
}

bool diskHit(float4 x, float dist)
{
    float thickness = 0.01;
    if(abs(x[2]) < thickness && dist < diskRadius && dist > horizonRadius)
    {
        return true;
    }
    else
    {
        return false;
    }
}

float Fract(float n)
{
    int nInt = (int)n;
    return n - abs(nInt);
}

float Random(float2 xz) 
{
    return Fract(sin(dot(xz, (12.9898,78.233))) * 43758.5453123);
}

float DiskNoise(float4 x)
{
    float rad = sqrt((x[1] * x[1]) + (x[3] * x[3]));
    // float intensity = sin((PI * rad) / diskRadius);
    // return Random((x[1], x[3])) * intensity;
    return abs(sin(PI * rad / diskRadius)* (0.01 + sin((PI * rad * 7.0) / diskRadius)));
    
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Break if already failed bounds check
    if (isComplete[id.xy] == 1) { return; }
    float4 x = Position[id.xy].xyzw;
    //float t = Position[id.xy].x;
    float3 camPos = x.yzw;
    float4 u = Direction[id.xy].xyzw;
    float dt = TimeStep[id.xy].x;
    float tol = ErrorTolerance[id.xy].x;

    bool isGood = ShootRay(dt, tol, x, u);   

    // Write back position and direction
    TimeStep[id.xy] = dt;
    if(isGood)
    {
        //t += dt;
        Position[id.xy]  = x;
        Direction[id.xy] = u;

    }
    else
    {
        return;
    }

    float dist = sqrt((x[1]*x[1]) + (x[2]*x[2]) + (x[3]*x[3]));

    bool hitDisk = diskHit(x, dist);

    float noise = DiskNoise(x);

    

    if((dist < 1.01 * horizonRadius))
    {
        // Blend black with previous color
        Color[id.xy] = Blend(Color[id.xy], float4(0.0, 0.0, 0.0, 0.0));

        // Set complete flag
        isComplete[id.xy] = 1;
    }

    if(hitDisk)
    {
        Color[id.xy] = Blend(Color[id.xy], noise * float4(0.2, 0.02, 0.0, 0.1));
       
    } 

    if(dist > 1000.0)
    {
        float4 skyboxColor = float4(SampleBackground(x, camPos), 1.0);
        // Blend with previous color value
        Color[id.xy] = Blend(Color[id.xy], skyboxColor);

        // Set complete flag
        isComplete[id.xy] = 1;
    }
    


}
