// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
//#pragma shader_feature STEREO_CUBEMAP_RENDER

// Constants
static const float PI = 3.14159265f;

float eps = 0.5;

float s = 0.0;

// Output parameters
RWTexture2D<float4> Position;
RWTexture2D<float4> Direction;
RWTexture2D<float4> Momentum;
RWTexture2D<float4> Color;
RWTexture2D<int> isComplete;
RWTexture2D<float> TimeStep;
RWTexture2D<float> ErrorTolerance;

// Input textures
Texture2D<float4> _SkyboxTexture;

#define ANALYTIC_METRIC
//#define FLAT_METRIC

#ifndef ANALYTIC_METRIC
#include "metric.cginc"
#else
static const float metric_horizon = 1.0;
static const float metric_dr = 0.01;
#endif

// Step size parameters
//float timeStep;

// Samplers
SamplerState sampler_SkyboxTexture;

// Physical parameters 
float diskRadius;

// Blend transparency and background colors
float4 Blend(float4 foreColor, float4 backColor)
{
    // Blend using previous color's alpha
    //float4 outColor = foreColor + backColor * (1.0 - foreColor.w);
    float4 outColor = foreColor + backColor;
    return outColor;
}

float3 SampleBackground(float4 x, float3 x_0)
{
    float dist = sqrt(((x[1] - x_0[0]) * (x[1] - x_0[0])) + ((x[2] - x_0[1]) * (x[2] - x_0[1])) + ((x[3] - x_0[2]) * (x[3] - x_0[2])));
    float theta = (acos((x[2] - x_0[1]) / dist)) / -PI;
    float phi = atan2((x[1] - x_0[0]), -(x[3] - x_0[2])) / PI * 0.5f;
    float3 skyAlpha = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    return skyAlpha;
}

float Pow7(float input)
{
    return input * input * input * input * input * input * input;
}

float Pow2(float input)
{
    return input * input;
}

float Pow3(float input)
{
    return input * input * input;
}

float Pow4(float input)
{
    return input * input * input * input;
}

/*
float Interpolate(float r, float values[METRIC_SIZE])
{
    int i = (r - metric_rmin) / metric_dr;
    i = max(0, i);
    i = min((METRIC_SIZE -1), i);

    float lambda = (r - metric_rmin - (i * metric_dr)) / metric_dr;

    return values[i] * (1 - lambda) + (values[i + 1] * lambda);
}
*/

float Lapse(float r)
{
#ifndef ANALYTIC_METRIC
    int i = (r - metric_rmin)/metric_dr;
    i = max(0, min(METRIC_SIZE - 2, i));
    //return metric_lapse[i];
    float lambda = (r - metric_rmin - (i * metric_dr)) / metric_dr;
    lambda = max(0.0, min(1.0, lambda));
    float v = metric_lapse[i]*(1 - lambda) + (metric_lapse[i+1]*lambda);
    return v;
#else
#ifndef FLAT_METRIC
    float rho_s = 1.0;
    return ((1 - rho_s / r) / (1 + rho_s / r));
#else
    return 1.0;
#endif
#endif
}

float Betar(float r)
{
    //int i = (r - metric_rmin)/metric_dr;
    //i = max(0, min(METRIC_SIZE - 2, i));
    //float lambda = (r - metric_rmin - (i * metric_dr)) / metric_dr;
    //lambda = max(0.0, min(1.0, lambda));
    //float v = metric_betar[i]*(1 - lambda) + (metric_betar[i+1]*lambda);
    //return v;
    return 0;
}

float Gammarr(float r)
{
#ifndef ANALYTIC_METRIC
    int i = (r - metric_rmin)/metric_dr;
    i = max(0, min(METRIC_SIZE - 2, i));
    float lambda = (r - metric_rmin - (i * metric_dr)) / metric_dr;
    lambda = max(0.0, min(1.0, lambda));
    float v = metric_grr[i]*(1 - lambda) + (metric_grr[i+1]*lambda);
    return v;
#else
#ifndef FLAT_METRIC
    float rho_s = 1.0;
    return Pow4(1 + (rho_s / r));
#else
    return 1.0;
#endif
#endif
}

float GammaT(float r)
{
#ifndef ANALYTIC_METRIC
    int i = (r - metric_rmin)/metric_dr;
    i = max(0, min(METRIC_SIZE - 2, i));
    float lambda = (r - metric_rmin - (i * metric_dr)) / metric_dr;
    lambda = max(0.0, min(1.0, lambda));
    float v = metric_gT[i]*(1 - lambda) + (metric_gT[i+1]*lambda);
    return v;
#else
#ifndef FLAT_METRIC
    float rho_s = 1.0;
    return Pow4(1 + (rho_s / r));
#else
    return 1.0;
#endif
#endif
}

float4x4 Metric(float4 xyz)
{
  float x = xyz[1];
  float y = xyz[2];
  float z = xyz[3];

  float rad = sqrt(Pow2(x) + Pow2(y) + Pow2(z));
  float r = sqrt((Pow2(rad)-Pow2(s)+sqrt(Pow2(Pow2(rad)-Pow2(s))+4.0*Pow2(s)*Pow2(z)))/2.0);

  if(r < eps)
  {
    r = eps / 2.0 + (r*r / (2*eps));
  }

  // Set covariant components
  // null vector l
  float l_lower[4];
  l_lower[0] = 1.0;
  l_lower[1] = (r*x + (s)*y)/( Pow2(r) + Pow2(s) );
  l_lower[2] = (r*y - (s)*x)/( Pow2(r) + Pow2(s) );
  l_lower[3] = z/r;

  // g_nm = f*l_n*l_m + eta_nm, where eta_nm is Minkowski metric

  float4x4 glower = 
    {
        {0., 0., 0., 0.},
        {0., 0., 0., 0.},
        {0., 0., 0., 0.},
        {0., 0., 0., 0.}
    };

  float f = 2.0 * Pow2(r)*r / (Pow2(Pow2(r)) + Pow2(s)*Pow2(z));

  glower[0][0] = f * l_lower[0]*l_lower[0] - 1.0;
  glower[0][1] = f * l_lower[0]*l_lower[1];
  glower[0][2] = f * l_lower[0]*l_lower[2];
  glower[0][3] = f * l_lower[0]*l_lower[3];
  glower[1][0] = glower[0][1];
  glower[1][1] = f * l_lower[1]*l_lower[1] + 1.0;
  glower[1][2] = f * l_lower[1]*l_lower[2];
  glower[1][3] = f * l_lower[1]*l_lower[3];
  glower[2][0] = glower[0][2];
  glower[2][1] = glower[1][2];
  glower[2][2] = f * l_lower[2]*l_lower[2] + 1.0;
  glower[2][3] = f * l_lower[2]*l_lower[3];
  glower[3][0] = glower[0][3];
  glower[3][1] = glower[1][3];
  glower[3][2] = glower[2][3];
  glower[3][3] = f * l_lower[3]*l_lower[3] + 1.0;

  return glower;

    /*float4x4 g_flat = 
    {
        {-1., 0., 0., 0.},
        {0., 1., 0., 0.},
        {0., 0., 1., 0.},
        {0., 0., 0., 1.}
    };
    return g_flat;*/
    
    // int a, b, c, d;

    // float r         = max(1e-6,sqrt(x[1]*x[1] + x[2]*x[2] + x[3]*x[3]));
    // float theta     = max(1e-6, min(PI - 1e-6, acos(x[3]/r)));
    // float phi       = atan2(x[2], x[1]);
    // float cos_theta = cos(theta);
    // float sin_theta = sin(theta);
    // float cos_phi   = cos(phi);
    // float sin_phi   = sin(phi);
    // float ir        = 1.0/r;
    // float csc_theta = 1.0/sin_theta;
    
    // float alpha = Lapse(r);
    // float betar = Betar(r);
    // float g_rr = Gammarr(r);
    // float g_T = GammaT(r);

    // float4x4 g_Spherical =
    // {
    // 	{-(Pow2(alpha) + g_rr * Pow2(betar)), g_rr * betar, 0., 0.},
    // 	{g_rr * betar, g_rr, 0., 0.},
    // 	{0., 0., g_T * r * r, 0.},
    // 	{0., 0., 0., g_T * Pow2(r * sin_theta)}
    // };

    // float4x4 g_Cartesian = 
    // {
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.}
    // };
    // float4x4 g_tmp = 
    // {
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.}
    // };

    // float4x4 J = {
    //     {1., 0., 0., 0.},
    //     {0.,  sin_theta * cos_phi, sin_theta * sin_phi, cos_theta},
    //     {0., ir * cos_theta * cos_phi, ir * cos_theta * sin_phi, - ir * sin_theta},
    //     {0., - ir * csc_theta * sin_phi, ir * csc_theta * cos_phi, 0.}
    // };
    
    // [unroll]
    // for(a = 0; a < 4; a++)
    // {
    //     [unroll]
    //     for(d = 0; d < 4; d++)
    //     {
    //         [unroll]
    //         for(c = 0; c < 4; c++)
    //         {
    //         	g_tmp[a][d] += g_Spherical[c][d] * J[c][a];
    //         }
    //     }
    // }
    // [unroll]
    // for(a = 0; a < 4; a++)
    // {
    //     [unroll]
    //     for(b = 0; b < 4; b++)
    //     {
    //         [unroll]
    //         for(d = 0; d < 4; d++)
    //         {
    //         	g_Cartesian[a][b] += g_tmp[a][d] * J[d][b];
    //         }
    //     }
    // }
    
    // return g_Cartesian;
}

float4x4 InverseMetric(float4 xyz)
{
    /*
    float4x4 g_flat = 
    {
        {-1., 0., 0., 0.},
        {0., 1., 0., 0.},
        {0., 0., 1., 0.},
        {0., 0., 0., 1.}
    };
    return g_flat;*/

    // int a, b, c, d;

    // float r         = max(1e-6,sqrt(x[1]*x[1] + x[2]*x[2] + x[3]*x[3]));
    // float theta     = max(1e-6, min(PI - 1e-6, acos(x[3]/r)));
    // float phi       = atan2(x[2], x[1]);
    // float cos_theta = cos(theta);
    // float sin_theta = sin(theta);
    // float cos_phi   = cos(phi);
    // float sin_phi   = sin(phi);

    // float alpha = Lapse(r);
    // float betar = Betar(r);
    // float g_rr = Gammarr(r);
    // float g_T = GammaT(r);

    // float4x4 g_Spherical =
    // {
    // 	{-1. / Pow2(alpha), betar / (Pow2(alpha)), 0., 0.},
    //     {betar / Pow2(alpha), (1. / (g_rr)) - Pow2(betar/alpha), 0., 0.},
  	// {0., 0., 1. / (g_T * r * r), 0.},
    // 	{0., 0., 0., 1. / (g_T * Pow2(r * sin_theta))},
    // };

    // float4x4 g_Cartesian = 
    // {
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.}
    // };
    // float4x4 g_tmp = 
    // {
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.},
    //     {0., 0., 0., 0.}
    // };

    // float4x4 J_inv =
    // {
    //     {1., 0., 0., 0.},
    //     {0., sin_theta * cos_phi, r * cos_theta * cos_phi, - r * sin_theta * sin_phi},
    //     {0., sin_theta * sin_phi, r * cos_theta * sin_phi, r * sin_theta * cos_phi},
    //     {0., cos_theta, - r * sin_theta, 0.}
    // };

    // [unroll]
    // for(a = 0; a < 4; a++)
    // {
    //     [unroll]
    //     for(d = 0; d < 4; d++)
    //     {
    //         [unroll]
    //         for(c = 0; c < 4; c++)
    //         {
    //             g_tmp[a][d] += g_Spherical[c][d] * J_inv[a][c];
    //         }
    //     }
    // }
    
    // [unroll]
    // for(a = 0; a < 4; a++)
    // {
    //     [unroll]
    //     for(b = 0; b < 4; b++)
    //     {
    //         [unroll]
    //         for(d = 0; d < 4; d++)
    //         {
    //             g_Cartesian[a][b] += g_tmp[a][d] * J_inv[b][d];
    //         }
    //     }
    // }
    
    // return g_Cartesian;

    float x = xyz[1];
    float y = xyz[2];
    float z = xyz[3];
  
  float rad = sqrt(Pow2(x) + Pow2(y) + Pow2(z));
  float r = sqrt((Pow2(rad)-Pow2(s)+sqrt(Pow2(Pow2(rad)-Pow2(s))+4.0*Pow2(s)*Pow2(z)))/2.0);
  
  if(r < eps)
  {
    r = eps/2 + (r*r / (2*eps));
  }

  // Set contravariant components
  // null vector l
  float l_upper[4];
  l_upper[0] = -1.0;
  l_upper[1] = (r*x + (s)*y)/( Pow2(r) + Pow2(s) );
  l_upper[2] = (r*y - (s)*x)/( Pow2(r) + Pow2(s) );
  l_upper[3] = z/r;

  float4x4 gupper = 
    {
        {0., 0., 0., 0.},
        {0., 0., 0., 0.},
        {0., 0., 0., 0.},
        {0., 0., 0., 0.}
    };

    float f = 2.0 * Pow2(r)*r / (Pow2(Pow2(r)) + Pow2(s)*Pow2(z));
    
  // g^nm = -f*l^n*l^m + eta^nm, where eta^nm is Minkowski metric
  gupper[0][0] = -f * l_upper[0]*l_upper[0] - 1.0;
  gupper[0][1] = -f * l_upper[0]*l_upper[1];
  gupper[0][2] = -f * l_upper[0]*l_upper[2];
  gupper[0][3] = -f * l_upper[0]*l_upper[3];
  gupper[1][0] = gupper[0][1];
  gupper[1][1] = -f * l_upper[1]*l_upper[1] + 1.0;
  gupper[1][2] = -f * l_upper[1]*l_upper[2];
  gupper[1][3] = -f * l_upper[1]*l_upper[3];
  gupper[2][0] = gupper[0][2];
  gupper[2][1] = gupper[1][2];
  gupper[2][2] = -f * l_upper[2]*l_upper[2] + 1.0;
  gupper[2][3] = -f * l_upper[2]*l_upper[3];
  gupper[3][0] = gupper[0][3];
  gupper[3][1] = gupper[1][3];
  gupper[3][2] = gupper[2][3];
  gupper[3][3] = -f * l_upper[3]*l_upper[3] + 1.0;

  return gupper;
}
    
float4x4 Derivative(float4 x, int a)
{
    float h = 2*metric_dr;
    float4 deltaPlus_x = x;
   
    deltaPlus_x[a] += h;
    float4x4 gPlus = Metric(deltaPlus_x);
    
    float4 deltaMinus_x = x;
    deltaMinus_x[a] -= h;
    float4x4 gMinus = Metric(deltaMinus_x);

    float4x4 dg;
    [unroll]
    for(int b = 0; b < 4; b++)
    {
        [unroll]
        for(int c = 0; c < 4; c++)
        {
            dg[b][c] = (gPlus[b][c] - gMinus[b][c]) / (2 * h);
        }
    }
    
    return dg;
}

bool ShootRay(inout float dt, float tol, inout float4 x_u, inout float4 u_u)
{
    int a, b, c;
    
    float4 rhs_x_u;
    float4 rhs_u_u;
    float4 rhs_u_d;

    float4 x_u_star;
    float4 u_d_star;
    float4 u_u_star;

    float4 x_u_euler;
    float4 u_d_euler;
    float4 u_u_euler;

    float4 u_d;

    float4x4 g_dd = Metric(x_u);

    bool isGood = false;
    float error;
    float dt_min = 1e-10;

    [unroll]
    for(a = 0; a < 4; a++)
    {
        u_d[a] = 0.0;
        [unroll]
        for(b = 0; b < 4; b++)
        {
            u_d[a] += g_dd[a][b] * u_u[b];
        }
    }

    [unroll]
    for(a = 0; a < 4; a++)
    {
        rhs_x_u[a] = -u_u[a];
        rhs_u_d[a] = 0.0;
        
        float4x4 dg_dd = Derivative(x_u, a); 
        [unroll]
        for(b = 0; b < 4; b++)
        {
            [unroll]
            for(c = 0; c < 4; c++)
            {
                rhs_u_d[a] -= ((0.5) * dg_dd[b][c] * u_u[b] * u_u[c]);
            }
        }
    }

    [unroll]
    for(a = 0; a < 4; a++)
    {
        x_u_star[a] = x_u[a] + (0.5)*dt*rhs_x_u[a];
        u_d_star[a] = u_d[a] + (0.5)*dt*rhs_u_d[a];
    }

    float4x4 g_uu = InverseMetric(x_u_star);
    [unroll]
    for(a = 0; a < 4; a++)
    {
        u_u_star[a] = 0.0;
        
        [unroll]
        for(b = 0; b < 4; b++)
        {
            u_u_star[a] += g_uu[a][b] * u_d_star[b];
        }
    }

    [unroll]
    for(a = 0; a < 4; a++)
    {
        x_u_euler[a] = x_u[a] + dt*rhs_x_u[a];
        u_d_euler[a] = u_d[a] + dt*rhs_u_d[a];
    }

    [unroll]
    for(a = 0; a < 4; a++)
    {
        rhs_x_u[a] = -u_u_star[a];
        
        float4x4 dg_dd = Derivative(x_u_star, a); 
        [unroll]
        for(b = 0; b < 4; b++)
        {
            [unroll]
            for(c = 0; c < 4; c++)
            {
                rhs_u_d[a] -= (0.5) * (dg_dd[b][c] * u_u_star[b] * u_u_star[c]);
            }
        }
    }

    [unroll]
    for(a = 0; a < 4; a++)
    {
        x_u_star[a] = x_u[a] + dt*rhs_x_u[a];
        u_d_star[a] = u_d[a] + dt*rhs_u_d[a];
    }

    error = 0.0;
    [unroll]
    for(a = 1; a < 4; a++)
    {
        error += abs(x_u_star[a] - x_u_euler[a]);
    }

    float dist = sqrt(x_u_star[1]*x_u_star[1] + x_u_star[2]*x_u_star[2] + x_u_star[3]*x_u_star[3]);
    error = error/max(1.0, dist);

    if(error < tol || dt <= dt_min)
    {
        isGood = true;
        [unroll]
        for(a = 0; a < 4; a++){
            x_u[a] = x_u_star[a];
        }

        [unroll]
        for(a = 0; a < 4; a++){ 
            u_d[a] = u_d_star[a];
        }

        g_uu = InverseMetric(x_u);
        [unroll]
        for(a = 0; a < 4; a++)
        {
            u_u[a] = 0.0;

            [unroll]
            for(b = 0; b < 4; b++)
            {
                u_u[a] += g_uu[a][b] * u_d[a];
            }
        }
        
        if(4*error < tol)
        {
            dt = dt * 2.0;
        }
    }

    else if(error > tol)
    {
        dt *= 0.5;
    } 
    return isGood;  
}

bool diskHit(float4 x, float dist)
{
    float thickness = 0.01;
    if(abs(x[2]) < thickness && dist < diskRadius && dist > metric_horizon)
    {
        return true;
    }
    else
    {
        return false;
    }
}

float Fract(float n)
{
    int nInt = (int)n;
    return n - abs(nInt);
}

float Random(float2 xz) 
{
    return Fract(sin(dot(xz, (12.9898,78.233))) * 43758.5453123);
}

float DiskNoise(float4 x)
{
    float rad = sqrt((x[1] * x[1]) + (x[3] * x[3]));
    // float intensity = sin((PI * rad) / diskRadius);
    // return Random((x[1], x[3])) * intensity;
    return abs(sin(PI * rad / diskRadius)* (0.01 + sin((PI * rad * 7.0) / diskRadius)));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Break if already failed bounds check
    if (isComplete[id.xy] == 1) { return; }
    float4 x = Position[id.xy].xyzw;
    float3 camPos = x.yzw;
    float4 u = Direction[id.xy].xyzw;
    float dt = TimeStep[id.xy].x;
    float tol = ErrorTolerance[id.xy].x;

    bool isGood = ShootRay(dt, tol, x, u);   

    // Write back position and direction
    TimeStep[id.xy] = dt;
    if(isGood)
    {
        Position[id.xy]  = x;
        Direction[id.xy] = u;
    }
    else
    {
        return;
    }

    float dist = sqrt((x[1]*x[1]) + (x[2]*x[2]) + (x[3]*x[3]));
    //bool hitDisk = diskHit(x, dist);
    //float noise = DiskNoise(x);

    if((dist < (1.0 + 10*tol) * metric_horizon))
    {
        Color[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
        isComplete[id.xy] = 1;
    }

    //if(hitDisk)
    //{
    //    Color[id.xy] = Blend(Color[id.xy], noise * float4(0.2, 0.02, 0.0, 0.1));
    //} 

    if(dist > 200.0)
    {
        float4 skyboxColor = float4(SampleBackground(x, camPos), 1.0);
        Color[id.xy] = skyboxColor;
        isComplete[id.xy] = 1;
    }
}
